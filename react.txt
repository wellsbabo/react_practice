react
구성요소는 기억을 위해 state를 사용
props를 통해 상태를 전달 가능

JSX 사용 = 거의 HTML과 비슷
jsx는 브라우저에서 이해못하기때문에 babel을 통해 변환해줘야함

<!-- JSX는 어플리케이션을 여러가지 작은 요소로 나누어 관리할 수 있게 해줌. 여러 요소로 잘게 쪼개서 만들어서 합쳐 주기만 하면 됨 -->

state는 기본적으로 데이터가 저장되는 저장소

데이터를 바꾸고 다시 랜더링
이전에 랜더링된것과 앞으로 랜더링 할것을 비교해서 다른 부분만 새로 생성해서 업데이트해줌
스테이트가 바뀌면 새로운 값을 가지고 컴포넌트가 리렌더링됨

state에서 데이터를 수정하기 위해 modifier 함수를 사용할때마다 컴포넌트는 새로운 데이터와 함께 새로고침됨
sate를 변화시킬때 모든게 새로고침된다!
리액트는 re-render가 필요한 것들만 re-render 할것이다
modifier 함수를 실행하면 모든 컴포넌트들이 다시 렌더링!
절대 state를 직접적으로 수정하지는 않는다

Props는 일종의 방식. 부모 컴포넌트로부터 자식 컴포넌트에 데이터를 보낼 수 있게 해주는 방법

하나의 컴포넌트를 하나의 파일로 만든다

app.js에 컴포넌트를 불러와서 사용하고 그 app.js를 index.js에 랜더링한다

style.css는 모든 요소들의 색을 일관되게 만들어주기때문에 굳이 사용하지않는다
그렇다고 하나하나 요소에 css를 따로 추가하기에도 번거롭다
-> CSS modules를 사용한다

state가 변화할 때 모든 컴포넌트는 다시 실행되고, 모든 코드들도 다시 실행된다
이게 괜찮을 때도 있지만 컴포넌트 내부의 몇몇 코드는 처음 딱 한번만 실행되고 다시는 실행되지 않도록 하고 싶을 수 있다 ex) API에서 데이터를 불러오는 것
-> useEffect 사용하면됨
useEffect()에는 컴포넌트가 처음 render할 때 실행되고 다시는 실행되지 않을 function을 넣어주면 된다
코드의 특정한 부분만이 변화했을 때, 원하는 코드들을 실행할 수 있는 방법

cleanup function을 사용하면 컴포넌트가 destroy될 때 동작하는 함수도 만들어줄 수 있음

npx create-react-app my-app

컴포넌트 생성

에러 발생을 방지하기 위해 타입을 확인하기 위해 ProTypes 사용

리액트 라우터는 페이지를 전환하게 한다
라우터별로 생각한다 -> 스크린별로 생각한다
App.js는 라우터를 render 해야한다
라우터는 URL을 보고있는 컴포넌트

URL에 따라 페이지를 이동시키고 그에 맞춘 컴포넌트를 랜더링하기 위해 react-router-dom 사용
Link를 사용하면 브라우저 새로고침 없이도 유저를 다른 페이지로 이동시켜줌
const {id} = useParams();을 통해서 URL의 파라미터를 가져온다

결론: state, setState, useEffect가 전부다.